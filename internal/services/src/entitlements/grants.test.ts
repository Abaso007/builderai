import type { Database } from "@unprice/db"
import type { Logger } from "@unprice/logging"
import { beforeEach, describe, expect, it, vi } from "vitest"
import { GrantsManager } from "./grants"

describe("GrantsManager", () => {
  let grantsManager: GrantsManager
  let mockDb: Database
  let mockLogger: Logger

  const now = Date.now()
  const customerId = "cust_grants_123"
  const projectId = "proj_grants_123"
  const featureSlug = "merge-test-feature"

  // Base grant object for reuse
  const baseGrant = {
    id: "grant_base",
    projectId,
    subjectType: "customer",
    subjectId: customerId,
    type: "subscription",
    featurePlanVersionId: "fpv_1",
    effectiveAt: now - 10000,
    expiresAt: now + 10000,
    deleted: false,
    autoRenew: true,
    priority: 10,
    featurePlanVersion: {
      feature: {
        slug: featureSlug,
      },
      featureType: "usage",
      aggregationMethod: "sum",
      billingConfig: {
        name: "billing",
        billingInterval: "month",
        billingIntervalCount: 1,
        planType: "recurring",
      },
      resetConfig: {
        name: "billing",
        resetInterval: "month",
        resetIntervalCount: 1,
        planType: "recurring",
        resetAnchor: 1,
      },
    },
    anchor: 1,
  }

  beforeEach(() => {
    vi.clearAllMocks()

    mockLogger = {
      error: vi.fn(),
    } as unknown as Logger

    mockDb = {
      query: {
        customers: {
          findFirst: vi.fn(),
        },
        grants: {
          findMany: vi.fn(),
        },
        entitlements: {
          findFirst: vi.fn(),
        },
      },
      insert: vi.fn(() => ({
        values: vi.fn(() => ({
          onConflictDoUpdate: vi.fn(() => ({
            returning: vi.fn().mockResolvedValue([{ id: "ent_new" }]),
          })),
        })),
      })),
    } as unknown as Database

    grantsManager = new GrantsManager({ db: mockDb, logger: mockLogger })
  })

  // Helper to mock DB responses
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  const setupMocks = (grantsList: any[]) => {
    // Mock customer subscription (always found)
    vi.spyOn(mockDb.query.customers, "findFirst").mockResolvedValue({
      subscriptions: [{ phases: [{ planVersion: { plan: { id: "plan_1" }, id: "pv_1" } }] }],
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    } as any)

    // We should only return the list ONCE, or filter by arguments if possible.
    // Or just mock implementation to return empty list for subsequent calls.
    let callCount = 0
    vi.spyOn(mockDb.query.grants, "findMany").mockImplementation(() => {
      if (callCount === 0) {
        callCount++
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        return grantsList as any
      }
      return []
    })

    // Mock existing entitlement (not found -> create new)
    vi.spyOn(mockDb.query.entitlements, "findFirst").mockResolvedValue(undefined)

    // Mock insert to return the object passed to it (simulating DB behavior for test purposes)
    vi.spyOn(mockDb, "insert").mockReturnValue({
      values: vi.fn().mockImplementation((values) => ({
        onConflictDoUpdate: vi.fn().mockImplementation((params) => ({
          returning: vi.fn().mockResolvedValue([
            {
              ...values, // Return the values we just inserted
              ...params.set, // Apply any updates
              id: "ent_new_1",
            },
          ]),
        })),
      })),
      // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    } as any)
  }

  describe("computeGrantsForCustomer - Merge Rules", () => {
    it("should sum limits for usage features", async () => {
      const grants = [
        {
          ...baseGrant,
          id: "g1",
          limit: 100,
          priority: 10,
          featurePlanVersion: { ...baseGrant.featurePlanVersion, featureType: "usage" },
        },
        {
          ...baseGrant,
          id: "g2",
          limit: 50,
          priority: 20,
          featurePlanVersion: { ...baseGrant.featurePlanVersion, featureType: "usage" },
        },
      ]

      setupMocks(grants)

      const result = await grantsManager.computeGrantsForCustomer({
        customerId,
        projectId,
        now,
      })

      expect(result.err).toBeUndefined()
      expect(result.val).toHaveLength(1)
      const entitlement = result.val![0]
      expect(entitlement).toBeDefined()
      expect(entitlement!.limit).toBe(150) // 100 + 50
      expect(entitlement!.mergingPolicy).toBe("sum")

      // Verify effectiveAt/expiresAt from min/max of grants
      expect(grants[0]).toBeDefined()
      expect(grants[1]).toBeDefined()
      const minStart = Math.min(grants[0]!.effectiveAt, grants[1]!.effectiveAt)
      const maxEnd = Math.max(grants[0]!.expiresAt, grants[1]!.expiresAt)
      expect(entitlement!.effectiveAt).toBe(minStart)
      expect(entitlement!.expiresAt).toBe(maxEnd)

      // Verify feature slug and type
      expect(entitlement!.featureSlug).toBe(featureSlug)
      expect(entitlement!.featureType).toBe("usage")
      expect(entitlement!.aggregationMethod).toBe("sum")
    })

    it("should take max limit for tier features", async () => {
      const tierFeature = { ...baseGrant.featurePlanVersion, featureType: "tier" }
      const grants = [
        {
          ...baseGrant,
          id: "g1",
          limit: 100,
          priority: 10,
          featurePlanVersion: tierFeature,
        },
        {
          ...baseGrant,
          id: "g2",
          limit: 500,
          priority: 20,
          featurePlanVersion: tierFeature,
        },
        {
          ...baseGrant,
          id: "g3",
          limit: 50,
          priority: 5,
          featurePlanVersion: tierFeature,
        },
      ]

      setupMocks(grants)

      const result = await grantsManager.computeGrantsForCustomer({
        customerId,
        projectId,
        now,
      })

      expect(result.err).toBeUndefined()
      const entitlement = result.val![0]
      expect(entitlement).toBeDefined()
      expect(entitlement!.limit).toBe(500) // Max of 100, 500, 50
      expect(entitlement!.mergingPolicy).toBe("max")

      // Verify aggregation method
      expect(entitlement!.aggregationMethod).toBe("sum")

      // Verify only the winning grant is kept in the entitlement
      expect(entitlement!.grants).toHaveLength(1)
      expect(entitlement!.grants[0]!.id).toBe("g2") // g2 has limit 500
    })

    it("should replace limits for flat features (highest priority wins)", async () => {
      const flatFeature = { ...baseGrant.featurePlanVersion, featureType: "flat" }
      const grants = [
        {
          ...baseGrant,
          id: "g_low",
          limit: 100,
          priority: 10,
          featurePlanVersion: flatFeature,
        },
        {
          ...baseGrant,
          id: "g_high",
          limit: 999,
          priority: 100, // Highest priority
          featurePlanVersion: flatFeature,
        },
      ]

      setupMocks(grants)

      const result = await grantsManager.computeGrantsForCustomer({
        customerId,
        projectId,
        now,
      })

      expect(result.err).toBeUndefined()
      const entitlement = result.val![0]
      expect(entitlement).toBeDefined()
      expect(entitlement!.limit).toBe(999)
      expect(entitlement!.mergingPolicy).toBe("replace")

      // Verify only the winning grant is kept in the entitlement
      expect(entitlement!.grants).toHaveLength(1)
      expect(entitlement!.grants[0]!.id).toBe("g_high") // g_high has priority 100

      // Verify reset config is taken from highest priority grant (if any)
      // Base grant has reset config.
      // Assuming highest priority grant (g_high) has it.
      expect(entitlement!.resetConfig).toBeDefined()
      // @ts-ignore
      expect(entitlement!.resetConfig!.name).toBe("billing")
      // @ts-ignore
      expect(entitlement!.resetConfig!.resetAnchor).toBe(1) // Matches baseGrant anchor
    })

    it("should allow overage if ANY grant allows it (sum policy)", async () => {
      const usageFeature = { ...baseGrant.featurePlanVersion, featureType: "usage" }
      const grants = [
        {
          ...baseGrant,
          id: "g_strict",
          limit: 100,
          allowOverage: false,
          featurePlanVersion: usageFeature,
        },
        {
          ...baseGrant,
          id: "g_loose",
          limit: 50,
          allowOverage: true,
          featurePlanVersion: usageFeature,
        },
      ]

      setupMocks(grants)

      const result = await grantsManager.computeGrantsForCustomer({
        customerId,
        projectId,
        now,
      })

      expect(result.err).toBeUndefined()
      const entitlement = result.val![0]
      expect(entitlement).toBeDefined()
      expect(entitlement!.allowOverage).toBe(true)
    })

    it("should allow overage if ANY grant allows it (max policy)", async () => {
      const tierFeature = { ...baseGrant.featurePlanVersion, featureType: "tier" }
      const grants = [
        {
          ...baseGrant,
          id: "g_strict",
          limit: 100,
          allowOverage: false,
          featurePlanVersion: tierFeature,
        },
        {
          ...baseGrant,
          id: "g_loose",
          limit: 50,
          allowOverage: true,
          featurePlanVersion: tierFeature,
        },
      ]

      setupMocks(grants)

      const result = await grantsManager.computeGrantsForCustomer({
        customerId,
        projectId,
        now,
      })

      expect(result.err).toBeUndefined()
      const entitlement = result.val![0]
      expect(entitlement).toBeDefined()
      expect(entitlement!.allowOverage).toBe(true)
    })

    it("should require ALL grants to allow overage for min policy (hypothetical)", async () => {
      // Min policy logic exists in code, though feature type mapping might not strictly use it yet
      // Simulating by mocking the merge logic or forcing a case if possible.
      // But verify function uses standard mergeGrants.
      // Let's just unit test `mergeGrants` logic indirectly via computeEntitlementFromGrants if possible?
      // Actually, we can't easily inject 'min' policy via feature type unless we change code or rely on 'package' maybe?
      // Code says: package -> max.
      // Let's skip strict min policy test if no feature type maps to it by default,
      // OR assume we might add one.
      // Wait, the switch case doesn't have 'min'.
      // So 'min' is only reachable if we manually call mergeGrants with 'min', which computeEntitlementFromGrants doesn't do.
      // So we skip testing 'min' integration here.
    })

    it("should fail if mixed feature types for same slug (should not happen ideally but uses highest priority)", async () => {
      // If grants have different feature types for the SAME slug,
      // `computeEntitlementFromGrants` determines policy based on the BEST priority grant.
      // It effectively ignores the type of lower priority grants for policy determination.

      const grants = [
        {
          ...baseGrant,
          id: "g_usage",
          limit: 100,
          priority: 10,
          featurePlanVersion: { ...baseGrant.featurePlanVersion, featureType: "usage" }, // usage -> sum
        },
        {
          ...baseGrant,
          id: "g_tier",
          limit: 500,
          priority: 100, // Highest -> wins policy determination
          featurePlanVersion: { ...baseGrant.featurePlanVersion, featureType: "tier" }, // tier -> max
        },
      ]

      setupMocks(grants)

      const result = await grantsManager.computeGrantsForCustomer({
        customerId,
        projectId,
        now,
      })

      expect(result.err).toBeUndefined()
      const entitlement = result.val![0]
      expect(entitlement).toBeDefined()

      // Highest priority is 'tier', so policy is 'max'.
      // Max(100, 500) = 500.
      expect(entitlement!.featureType).toBe("tier")
      expect(entitlement!.mergingPolicy).toBe("max")
      expect(entitlement!.limit).toBe(500)
    })
  })
})
