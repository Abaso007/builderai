import { env } from "cloudflare:workers"
import { createRoute } from "@hono/zod-openapi"
import { and, eq } from "@unprice/db"
import { customers } from "@unprice/db/schema"
import * as HttpStatusCodes from "stoker/http-status-codes"
import { z } from "zod"
import { UnpriceApiError, openApiErrorResponses } from "~/errors"
import type { App } from "~/hono/app"

const tags = ["paymentProvider"]

export const route = createRoute({
  path: "/v1/paymentProvider/stripe/setup/{sessionId}/{projectId}",
  // this endpoint is not public, so we hide it
  hide: env.NODE_ENV === "production",
  summary: "stripe setup",
  description:
    "This endpoint is called by stripe after the customer setup a payment method. No webhook is needed.",
  method: "get",
  tags,
  request: {
    params: z.object({
      projectId: z.string().openapi({
        description: "The project id the customer is signing up for",
        example: "1234567890",
      }),
      sessionId: z.string().openapi({
        description: "The stripe session generated by the sign up process",
        example: "cs_live_a1b2c3d4e5f6g7h8i9j0",
      }),
    }),
  },
  responses: {
    ...openApiErrorResponses,
    [HttpStatusCodes.MOVED_TEMPORARILY]: {
      description: "Redirect",
      headers: {
        Location: {
          description: "URL to redirect to",
          schema: {
            type: "string",
            format: "uri",
          },
        },
      },
    },
  },
})

const stripeSetupMetadataSchema = z.object({
  customerId: z.string().describe("The stripe customer id"),
  successUrl: z.string().url().describe("The success url"),
  cancelUrl: z.string().url().describe("The cancel url"),
})

export type StripeSetupRequest = z.infer<typeof route.request.params>

export const registerStripeSetupV1 = (app: App) =>
  app.openapi(route, async (c) => {
    const { sessionId, projectId } = c.req.valid("param")
    const key = c.req.header("cf-connecting-ip") ?? c.req.header("x-forwarded-for") ?? projectId
    const { customer, db, logger } = c.get("services")

    // rate limit the request
    const result = await c.env.RL_FREE_600_60s.limit({ key })

    if (!result) {
      throw new UnpriceApiError({
        code: "RATE_LIMITED",
        message: "Rate limit exceeded, please don't DDos me :(",
      })
    }

    // get payment provider for the project
    const { err: paymentProviderErr, val: paymentProviderService } =
      await customer.getPaymentProvider({
        projectId,
        provider: "stripe",
      })

    if (paymentProviderErr) {
      throw paymentProviderErr
    }

    // get session data from stripe
    const { err: getSessionErr, val: stripeSession } = await paymentProviderService.getSession({
      sessionId,
    })

    if (getSessionErr) {
      throw getSessionErr
    }

    // validate metadata it needs to be present and valid
    const metadata = stripeSetupMetadataSchema.safeParse(stripeSession.metadata)

    if (!metadata.success) {
      throw new UnpriceApiError({
        code: "BAD_REQUEST",
        message: `Invalid metadata for stripe setup: ${metadata.error.message}`,
      })
    }

    // set customer id so we can use it in the next request
    paymentProviderService.setCustomerId(stripeSession.customerId)

    // get payment methods if available
    const { err: getPaymentMethodsErr, val: paymentMethods } =
      await paymentProviderService.listPaymentMethods({
        limit: 1,
      })

    if (getPaymentMethodsErr) {
      throw getPaymentMethodsErr
    }

    // parameters for the sign up process
    const defaultPaymentMethodId = paymentMethods.at(0)?.id ?? null

    // check if the customer exists in the database
    const customerData = await db.query.customers.findFirst({
      where: (customer, { and, eq }) =>
        and(eq(customer.id, metadata.data.customerId), eq(customer.projectId, projectId)),
    })

    if (!customerData) {
      throw new UnpriceApiError({
        code: "NOT_FOUND",
        message: "Unprice customer not found in database",
      })
    }

    // update the customer
    await db
      .update(customers)
      .set({
        stripeCustomerId: stripeSession.customerId,
        metadata: {
          ...customerData?.metadata,
          stripeSubscriptionId: stripeSession.subscriptionId ?? "",
          stripeDefaultPaymentMethodId: defaultPaymentMethodId ?? "",
          // analytics
          colo: c.get("analytics").colo,
          country: c.get("analytics").country,
          city: c.get("analytics").city,
          isEUCountry: c.get("analytics").isEUCountry,
          region: c.get("analytics").region,
          continent: c.get("analytics").continent,
        },
      })
      .where(and(eq(customers.id, customerData.id), eq(customers.projectId, projectId)))
      .execute()
      .catch((err) => {
        logger.error(`Error updating customer: ${err.message}`)

        throw new UnpriceApiError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Error updating customer",
        })
      })

    // in development wrangler do weird things with the url
    if (c.env.NODE_ENV === "development") {
      return c.html(`
        <html>
          <head>
            <meta http-equiv="refresh" content="0;url=${metadata.data.successUrl}" />
          </head>
          <body>
            Redirecting from client side (only in development)...
          </body>
        </html>
      `)
    }

    // redirect to the success URL
    return c.redirect(metadata.data.successUrl, HttpStatusCodes.SEE_OTHER)
  })
