import { env } from "cloudflare:workers"
import { createRoute } from "@hono/zod-openapi"
import { customers } from "@unprice/db/schema"
import * as HttpStatusCodes from "stoker/http-status-codes"
import { z } from "zod"
import { UnpriceApiError, openApiErrorResponses } from "~/errors"
import type { App } from "~/hono/app"

const tags = ["paymentProvider"]

export const route = createRoute({
  path: "/v1/paymentProvider/stripe/signUp/{sessionId}/{projectId}",
  // this endpoint is not public, so we hide it
  hide: env.NODE_ENV === "production",
  description:
    "This endpoint is called by stripe after the customer has signed up. No webhook is needed.",
  method: "get",
  tags,
  request: {
    params: z.object({
      projectId: z.string().openapi({
        description: "The project id the customer is signing up for",
        example: "1234567890",
      }),
      sessionId: z.string().openapi({
        description: "The stripe session generated by the sign up process",
        example: "cs_live_a1b2c3d4e5f6g7h8i9j0",
      }),
    }),
  },
  responses: {
    ...openApiErrorResponses,
    [HttpStatusCodes.MOVED_TEMPORARILY]: {
      description: "Redirect",
      headers: {
        Location: {
          description: "URL to redirect to",
          schema: {
            type: "string",
            format: "uri",
          },
        },
      },
    },
  },
})

const stripeSignUpMetadataSchema = z.object({
  customerSessionId: z.string().describe("The unprice customer session id"),
  successUrl: z.string().url().describe("The success url"),
  cancelUrl: z.string().url().describe("The cancel url"),
})

export type StripeSignUpRequest = z.infer<typeof route.request.params>

// TODO: implement rate limiting because this endpoint is public
export const registerStripeSignUpV1 = (app: App) =>
  app.openapi(route, async (c) => {
    const { sessionId, projectId } = c.req.valid("param")
    const { customer, db, subscription } = c.get("services")

    // get payment provider for the project
    const { err: paymentProviderErr, val: paymentProviderService } =
      await customer.getPaymentProvider({
        projectId,
        provider: "stripe",
      })

    if (paymentProviderErr) {
      throw paymentProviderErr
    }

    // get session data from stripe
    const { err: getSessionErr, val: stripeSession } = await paymentProviderService.getSession({
      sessionId,
    })

    if (getSessionErr) {
      throw getSessionErr
    }

    // validate metadata it needs to be present and valid
    const metadata = stripeSignUpMetadataSchema.safeParse(stripeSession.metadata)

    if (!metadata.success) {
      throw new UnpriceApiError({
        code: "BAD_REQUEST",
        message: `Invalid metadata for stripe sign up: ${metadata.error.message}`,
      })
    }

    // set customer id so we can use it in the next request
    paymentProviderService.setCustomerId(stripeSession.customerId)

    // get payment methods if available
    const { err: getPaymentMethodsErr, val: paymentMethods } =
      await paymentProviderService.listPaymentMethods({
        limit: 1,
      })

    if (getPaymentMethodsErr) {
      throw getPaymentMethodsErr
    }

    // parameters for the sign up process
    const defaultPaymentMethodId = paymentMethods.at(0)?.id ?? null

    // get the customer session
    const customerSession = await db.query.customerSessions.findFirst({
      where: (customerSession, { and, eq }) =>
        and(eq(customerSession.id, metadata.data.customerSessionId)),
    })

    if (!customerSession) {
      throw new UnpriceApiError({
        code: "NOT_FOUND",
        message: "Customer session not found",
      })
    }

    // upsert the customer
    const customerUnprice = await db
      .insert(customers)
      .values({
        id: customerSession.customer.id,
        projectId: customerSession.customer.projectId,
        stripeCustomerId: stripeSession.customerId,
        name: customerSession.customer.name ?? "",
        email: customerSession.customer.email ?? "",
        defaultCurrency: customerSession.customer.currency,
        active: true,
        timezone: customerSession.customer.timezone,
        metadata: {
          stripeSubscriptionId: stripeSession.subscriptionId ?? "",
          stripeDefaultPaymentMethodId: defaultPaymentMethodId ?? "",
          externalId: customerSession.customer.externalId,
        },
      })
      .onConflictDoUpdate({
        target: [customers.id],
        set: {
          stripeCustomerId: stripeSession.customerId,
          name: customerSession.customer.name ?? "",
          email: customerSession.customer.email ?? "",
          defaultCurrency: customerSession.customer.currency,
          active: true,
          timezone: customerSession.customer.timezone,
          metadata: {
            stripeSubscriptionId: stripeSession.subscriptionId ?? "",
            stripeDefaultPaymentMethodId: defaultPaymentMethodId ?? "",
            externalId: customerSession.customer.externalId,
          },
        },
      })
      .returning()
      .then((result) => result.at(0))

    if (!customerUnprice) {
      throw new UnpriceApiError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Failed to upsert customer",
      })
    }

    // create the subscription
    await subscription.createSubscription({
      projectId: customerSession.customer.projectId,
      input: {
        customerId: customerUnprice.id,
        phases: [
          {
            startAt: Date.now(),
            planVersionId: customerSession.planVersion.id,
            config: customerSession.planVersion.config,
            paymentMethodId: defaultPaymentMethodId,
          },
        ],
      },
    })

    // redirect to the success URL
    return c.redirect(metadata.data.successUrl, HttpStatusCodes.MOVED_TEMPORARILY)
  })
